@namespace Blazor.Sonner
@implements IDisposable
@inject DomInterop DomInterop

<li @ref="@_toastRef"
    style="
--index: @Index;
--toasts-before: @Index;
--z-index: @(Toasts.Count - Index);
--offset: @($"{( _isRemoved ? _offsetBeforeRemove.ToString( CultureInfo.InvariantCulture ) : _offset.ToString( CultureInfo.InvariantCulture ) )}px");
--initial-height: @(Toaster.Expand ? "auto" : $"{_initialHeight.ToString( CultureInfo.InvariantCulture )}px");
"
    tabindex="0"
    data-sonner-toast
    data-type="@Model.Type.ToString().ToLower()"
    data-styled="true"
    data-rich-colors="@Toaster.RichColors.ToAttr()"
    data-mounted="@_isMounted.ToAttr()"
    data-removed="@_isRemoved.ToAttr()"
    data-visible="@_isVisible.ToAttr()"
    data-expanded="@(( _isExpanded || ( Toaster.Expand && _isMounted ) ).ToAttr())"
    data-front="@_isFront.ToAttr()"
    data-promise="@Model.IsAsync.ToAttr()"
    data-swipe-out="false"
    data-y-position="@_position.Y"
    data-x-position="@_position.X">
    @if( Toaster.CloseButton && Model.Type is not ToastType.Loading )
    {
        <button aria-label="Close toast"
                data-disabled="@_isDisabled.ToAttr()"
                data-close-button
                @onclick="@DismissAsync">
            @Components.Assets.CloseIcon
        </button>
    }

    @if( Model.Type is not ToastType.Default )
    {
        <div data-icon>
            @if( Model.IsAsync )
            {
                @Components.Assets.Loader( Model.Type is ToastType.Loading )
            }

            @if( Model.Type is not ToastType.Loading )
            {
                @Icon
            }
        </div>
    }

    <div data-content>
        <div data-title>@Model.Title</div>
        @if( !string.IsNullOrWhiteSpace( Model.Description ) )
        {
            <div data-description>@Model.Description</div>
        }
    </div>
</li>

@code {
    [Parameter] public int Index { get; set; }
    [Parameter] public ToastModel Model { get; set; } = default!;
    [Parameter] public ToastPosition Position { get; set; } = ToastPosition.BottomRight;
    [Parameter] public EventCallback<Guid> OnDismiss { get; set; }
    [Parameter] public EventCallback<Guid> OnDismissing { get; set; }
    [Parameter] public EventCallback<Height> OnHeightChanged { get; set; }

    [CascadingParameter] private Toaster Toaster { get; set; } = default!;

    private List<ToastModel> Toasts => Toaster.FilteredToasts;
    private RenderFragment? Icon => Model.Type switch
    {
        ToastType.Success => Components.Assets.SuccessIcon,
        ToastType.Error => Components.Assets.ErrorIcon,
        ToastType.Info => Components.Assets.InfoIcon,
        ToastType.Warning => Components.Assets.WarningIcon,
        _ => null
    };

    private ToastTimer? _timer;
    private ToastType _previousType;

    private bool _isMounted;
    private bool _isRemoved;
    private bool _isVisible;
    private bool _isExpanded;
    private bool _isFront;
    private bool _isDisabled;

    private int _heightIndex;
    private double _offset;
    private double _offsetBeforeRemove;
    private double _initialHeight;
    private double _previousToastsHeight;

    private (string Y, string X) _position;

    private ElementReference _toastRef;

    protected override void OnInitialized()
    {
        _timer = new ToastTimer( Toaster.Duration );
        _timer.OnCompleted += () => InvokeAsync( DismissAsync );

        _previousType = Model.Type;

        if( _previousType is not ToastType.Loading )
        {
            _timer.Start();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Handle promise toast state transition: Loading → Success/Error
        if( _previousType is ToastType.Loading && Model.Type is not ToastType.Loading )
        {
            // Promise resolved - start the auto-dismiss timer
            _timer?.Start();

            // Update height in case description has changed
            await SetHeightAsync();
        }

        _previousType = Model.Type;
        _position = Utils.MapPosition( Position );

        _isFront = Index == 0;
        _isVisible = Index + 1 <= Toaster.VisibleToasts;
        _isExpanded = Toaster.Expanded;
        _isDisabled = Model.Type is ToastType.Loading;

        _heightIndex = Math.Max( 0, Toaster.ToastHeights.FindIndex( h => h.ToastId == Model.Id ) );
        _previousToastsHeight = Toaster.ToastHeights.Take( _heightIndex ).Sum( h => h.Value );
        _offset = _heightIndex * Toaster.Gap + _previousToastsHeight;
    }

    protected override async Task OnAfterRenderAsync( bool firstRender )
    {
        if( firstRender )
        {
            // Trigger enter animation without using CSS animation
            await SetMountedAsync( true );
            await SetHeightAsync();
        }

        // Don't pause/resume timer for loading toasts (timer isn't running)
        if( Model.Type is ToastType.Loading ) return;

        if( _isExpanded )
        {
            _timer?.Pause();
        }
        else
        {
            _timer?.Resume();
        }
    }

    private async ValueTask SetMountedAsync( bool value )
    {
        await DomInterop.RequestAnimationFrameAsync();

        _isMounted = value;
        StateHasChanged();
    }

    private async Task DismissAsync()
    {
        if( _isDisabled ) return;

        _isRemoved = true;
        _offsetBeforeRemove = _offset;

        await OnDismissing.InvokeAsync( Model.Id );
        await Task.Delay( Constants.TimeBeforeUnmount ); // Match with CSS transition duration
        await OnDismiss.InvokeAsync( Model.Id );
    }

    private async Task SetHeightAsync()
    {
        var height = ( await DomInterop.GetBoundingClientRectAsync( _toastRef ) ).Height;
        _initialHeight = height;

        await OnHeightChanged.InvokeAsync( new Height( Model.Id, height ) );
    }

    void IDisposable.Dispose()
    {
        _timer?.Dispose();
    }
}
